# Python Basic
✅ **목표**
- 데이터 분석을 위해 필요한 Python 문법 이해
- 자료구조 접근을 위한 indexing, slicing 개념 이해
- Python 자료형 종류 & 함수 이해


### *Why Python?*

1. ML/DL 친화적인 패키지 및 라이브러리 활용
2. 데이터 분석, 전처리를 보다 직관적이고 쉽게
3. AI 알고리즘 활용 호환 (Tensorflow, Keras, …)

<br/>

## 파이썬 변수
**변수**
- ‘변할 수 있는 것’으로 어떠한 값을 담는 ‘상자’와 같음
- A = 100이라고 하는 것은 ‘100을 A라고 하는 상자(변수)에 담아줘!’ 라는 의미
    **변수를 선언한다. → (일반적인 ‘=’의 의미를 프로그램에서는 ‘==’로 사용)**
    

**변수 할당**

- 변수명과 값을 연결하는 과정 → `변수명 = 값`

```python
a = 10 # 변수에 값을 지정 = 사용
```

- 변수 a에 정수 100을 할당하는 의미로, 메모리 어딘가에 100을 저장하고 x가 이를 가리키도록 함
    
    **→ 참조 (reference)**
    

```python
# 변수 할당해야 할 값이 100인 경우
a1 = 100
a2 = 100
a3 = 100
...
a100 = 100
```

→ 코드 길이도 길어지고, 유지보수도 어려워짐

→ 더 큰 문제는 **메모리 낭비**

<br/>

💡 **파이썬의 정수 객체 인터닝(Integer Interning)**

- 파이썬은 `-5 ~ 256` 범위의 정수 → 미리 메모리에 저장
- 같은 값을 가진 변수를 만들면 새로운 메모리를 할당하는 것이 아니라, 기존 객체 참조하게끔 설계됨

```python
a = 100
b = 100
c = 100

print(id(a), id(b), id(c)) # 4378110832
```

✅ 하지만 100 이상의 숫자가 많아지면, 별도의 객체가 생성될 수 있음

<br/>

**(1) 코드 가독성 문제**

- 변수를 독립적으로 할당하면 유지보수가 어렵고,
    
    변수 이름이 `a1, a2, … ,a100` 와 같다면 특정 변수 찾기 어려워 수정하기 불편
    
<br/>

**(2) 메모리 사용 문제**

- 정수 `100`을 100개의 변수에 할당하는 경우, 파이썬이 동일한 객체를 재사용할 수도 있지만, 일반적으로 개별 값을 다루게 되면 메모리 낭비가 발생할 수 있음

```python
x1 = 9999
x2 = 9999
print(id(x1), id(x2)) >>> 5230581200 5230582608
```

✅ 큰 숫자나 리스트/딕셔너리 같은 데이터 구조는 새로운 객체가 생성됨
✅ 100개의 변수를 따로 관리하는 것은 비효율적임

→ 리스트 사용

<br/>

## **리스트를 사용하면**
- 파이썬에는 **여러 개의 값을 한꺼번에 저장할 수 있는 데이터 구조**가 있음
    → **리스트(List)** 가 가장 대표적
    

```python
numbers = [100] * 100  # 100개의 요소를 가진 리스트 생성
```

위 코드의 핵심은 `100`을 **한 번만 저장하고** 리스트 내에서 이를 **100번 참조하는 것**

→ 즉, `100`이라는 값을 **반복해서 새로 할당하는 것이 아니라, 같은 객체를 가리킴**

```python
print(id(numbers[0]), id(numbers[1]), id(numbers[99]))  # 모두 같은 메모리 주소
```

<br/>

*뭐가 좋은데?*

1. **코드가 짧고 직관적**
2. **변수를 따로 관리할 필요가 없음**
3. **메모리 낭비 없이 효율적**

*만약 값이 다른 경우라면?* → **리스트 컴프리헨션을 활용**

```python
numbers = [i for i in range(100)]
```

이렇게 하면 **0부터 99까지 자동으로 리스트에 저장**되니까, 100개의 변수를 각각 선언할 필요가 없음

<br/>

💡 **결론**

✔️ 변수를 하나씩 따로 관리하는 것은 **비효율적**

✔️ 특히, 개별 변수에 값을 할당하면 **코드가 길어지고 유지보수가 어려움**

✔️ **리스트**를 사용하면 많은 값을 **한 번에 저장**할 수 있어 **가독성과 메모리 효율성이 증가**

✔️ 동일한 값의 반복이라면, **객체 재사용을 통해 메모리 절약이 가능**

*→ 즉, **여러 개의 값을 다뤄야 한다면 리스트를 사용하자!** 🚀*

<br/>

**사용 예시**

```python
num = [2, 3, 'AA']
num[0] >> 2 # 리스트 변수 num의 첫번째 요소 접근
num[1] >> 3 # 리스트 변수 num의 두번째 요소 접근
num[2] >> 'AA' # 리스트 변수 num의 세번째 요소 접근
num[-1] >> 'AA' # 리스트 변수 num의 마지막 요소 접근
```

<br/>
<br/>

## 딕셔너리: **키(Key)로 바로 찾는 스마트 데이터 구조**

***📌 왜 딕셔너리가 필요할까?***

- 데이터를 저장할 때, 리스트(`list`)를 많이 사용함

→ 그런데 **리스트는 특정 값을 찾을 때 비효율적**

예를 들어, 학생들의 시험 점수를 저장하는 경우

```python
scores = [90, 85, 78, 92]
```

→ 리스트만 보고는 **누가 몇 점을 받았는지 알 수 없음**

```python
print(scores[0])  # 90 → 이게 누구 점수인지 모름
```

만약 **학생 이름과 점수를 매칭해야 한다면? → 딕셔너리(Dictionary)**

<br/>

---

### **📌 딕셔너리의 기본 개념**

- **Key-Value(키-값) 쌍**으로 데이터를 저장하는 구조

```python
scores = {
    "철수": 90,
    "영희": 85,
    "민수": 78
}
```

여기서:

- **Key** = `"철수"`, `"영희"`, `"민수"`
- **Value** = `90`, `85`, `78`

✅ **Key만 알면 바로 값을 찾을 수 있음!**

```python
print(scores["철수"])  # 90
```

리스트처럼 `index`로 찾는 게 아니라, **Key**로 바로 접근 가능! 🚀

<br/>

---

### **📌 딕셔너리 주요 기능**

**1️⃣ 값 추가 & 수정**

딕셔너리는 새로운 데이터를 쉽게 추가 가능

```python
scores["지수"] = 95  # 새 데이터 추가
scores["철수"] = 88  # 기존 데이터 수정
print(scores)
# {'철수': 88, '영희': 85, '민수': 78, '지수': 95}
```

**2️⃣ 값 삭제**

```python
del scores["민수"]  # '민수' 삭제
print(scores)
# {'철수': 88, '영희': 85, '지수': 95}
```

**3️⃣ 키(Key) 존재 여부 확인**

```python
print("영희" in scores)  # True
print("민수" in scores)  # False
```

<br/>

💡 **리스트 vs. 딕셔너리 차이점**

|  | 리스트(`list`) | 딕셔너리(`dict`) |
| --- | --- | --- |
| **데이터 저장** | 값만 저장 | 키-값 쌍 저장 |
| **데이터 접근** | `O(N)` (순차 탐색 필요) | `O(1)` (Key로 바로 접근 가능) |
| **사용 예시** | 번호별 학생 목록 | 학생별 성적 관리 |

<br/>
<br/>

## 조건문 (if문): **프로그램의 선택 능력 🧠**

***왜 조건문이 필요할까?***

- 사람들은 항상 **선택을 하면서 행동함**
    
    예를 들어, "비가 온다면 우산을 가져간다."
    
    → 이런 식의 논리를 프로그램에서도 사용할 수 있어야 함!
    
    = **조건문 (if문)**
    
<br/>

---

### **📌 if문의 기본 구조**

```python
if 조건식:
    실행할 코드
```

```python
**# 예제 1: 날씨에 따라 행동하기**
rain = True

if rain:
    print("우산을 가져간다.")
```

✅ `rain`이 `True`이므로 `"우산을 가져간다."` 가 출력됨.

<br/>

---

### **📌 else & elif 사용하기**

```python
# **예제 2: 성적에 따른 학점 부여**
score = 85

if score >= 90:
    print("A 학점")
elif score >= 80:
    print("B 학점")
elif score >= 70:
    print("C 학점")
else:
    print("F 학점")

```

✅ 점수가 `85`이므로 `"B 학점"`이 출력됨.

```python
**# 여러 개의 조건을 동시에 체크하려면?**
age = 20
money = 5000

if age >= 18 and money >= 3000:
    print("영화를 볼 수 있다.")
else:
    print("영화를 볼 수 없다.")
```

✅ `and` 연산자를 사용해 **두 개의 조건이 모두 참(True)일 때만 실행**되도록 함.

<br/>

---

### **📌 조건문의 핵심 개념**

| 개념 | 설명 |
| --- | --- |
| `if` | 조건이 `True`이면 실행 |
| `elif` | 다른 조건을 추가할 때 사용 |
| `else` | 모든 조건이 `False`일 때 실행 |
| 비교 연산자 | `==, !=, >, <, >=, <=` |
| 논리 연산자 | `and, or, not` |

<br/>
<br/>

## **반복문 (for문): 자동화의 시작 🔄**

***📌 왜 반복문이 필요할까?***

똑같은 코드를 여러 번 실행해야 할 때, 하나하나 작성하면 비효율적임.

```python
# **예제: 1부터 5까지 숫자 출력**
print(1)
print(2)
print(3)
print(4)
print(5)
```

이렇게 작성하는 대신, **for문을 사용하면 코드가 훨씬 간결해짐!**

```python
for i in range(1, 6):
    print(i)
```

✅ 같은 결과를 반복적으로 실행하면서도 **코드 길이를 줄일 수 있음!**

<br/>

---

### **📌 for문의 기본 구조**

```python
for 변수 in 반복할 값들:
    실행할 코드
```

- **반복할 값들**: 리스트, 튜플, 문자열 등 **`반복 가능한(iterable)` 데이터**
- **변수**: 반복될 때마다 값이 바뀌는 변수

<br/>

---

### **📌 range() 함수: 반복을 위한 숫자 생성기 🔢**

`range(start, stop, step)` 형태로 사용하며, **연속된 정수를 생성**하는 함수

**1️⃣ 기본 사용법**

```python
for i in range(5):  # 0부터 4까지 반복 (0, 1, 2, 3, 4)
    print(i)
```

**2️⃣ 특정 범위 지정**

```python
for i in range(2, 6):  # 2부터 5까지 (2, 3, 4, 5)
    print(i)
```

**3️⃣ 간격 조정**

```python
for i in range(1, 10, 2):  # 1부터 9까지 2씩 증가 (1, 3, 5, 7, 9)
    print(i)
```

<br/>

---

### **📌 for문 활용 예제**

**1️⃣ 리스트 반복**

```python
fruits = ["사과", "바나나", "체리"]

for fruit in fruits:
    print(fruit)
    
>> 사과
>> 바나나
>> 체리
```

**2️⃣ 문자열 반복**

```python
for char in "Python":
    print(char)
    
    
>> P
>> y
>> t
>> h
>> o
>> n
```

**3️⃣ 리스트의 인덱스와 함께 반복**

```python
numbers = [10, 20, 30]

for index, value in enumerate(numbers):
    print(f"Index {index}: {value}")
    
>> Index 0: 10
>> Index 1: 20
>> Index 2: 30
```

<br/>

---

💡 **결론: 딕셔너리, 조건문, 반복문의 핵심**

| 개념 | 설명 | 예제 |
| --- | --- | --- |
| **딕셔너리** | Key-Value 구조로 데이터를 저장 | `dict = {"name": "철수", "age": 20}` |
| **조건문** | 조건에 따라 실행 여부 결정 | `if age >= 18: print("성인")` |
| **반복문** | 여러 번 같은 작업을 수행 | `for i in range(5): print(i)` |
