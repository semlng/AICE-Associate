# Python Basic
✅ **목표**
- 데이터 분석을 위해 필요한 Python 문법 이해
- 자료구조 접근을 위한 indexing, slicing 개념 이해
- Python 자료형 종류 & 함수 이해


### *Why Python?*

1. ML/DL 친화적인 패키지 및 라이브러리 활용
2. 데이터 분석, 전처리를 보다 직관적이고 쉽게
3. AI 알고리즘 활용 호환 (Tensorflow, Keras, …)

<br/>

## 파이썬 변수
**변수**
- ‘변할 수 있는 것’으로 어떠한 값을 담는 ‘상자’와 같음
- A = 100이라고 하는 것은 ‘100을 A라고 하는 상자(변수)에 담아줘!’ 라는 의미
    **변수를 선언한다. → (일반적인 ‘=’의 의미를 프로그램에서는 ‘==’로 사용)**
    

**변수 할당**

- 변수명과 값을 연결하는 과정 → `변수명 = 값`

```python
a = 10 # 변수에 값을 지정 = 사용
```

- 변수 a에 정수 100을 할당하는 의미로, 메모리 어딘가에 100을 저장하고 x가 이를 가리키도록 함
    
    **→ 참조 (reference)**
    

```python
# 변수 할당해야 할 값이 100인 경우
a1 = 100
a2 = 100
a3 = 100
...
a100 = 100
```

→ 코드 길이도 길어지고, 유지보수도 어려워짐

→ 더 큰 문제는 **메모리 낭비**

<br/>

💡 **파이썬의 정수 객체 인터닝(Integer Interning)**

- 파이썬은 `-5 ~ 256` 범위의 정수 → 미리 메모리에 저장
- 같은 값을 가진 변수를 만들면 새로운 메모리를 할당하는 것이 아니라, 기존 객체 참조하게끔 설계됨

```python
a = 100
b = 100
c = 100

print(id(a), id(b), id(c)) # 4378110832
```

✅ 하지만 100 이상의 숫자가 많아지면, 별도의 객체가 생성될 수 있음

<br/>

**(1) 코드 가독성 문제**

- 변수를 독립적으로 할당하면 유지보수가 어렵고,
    
    변수 이름이 `a1, a2, … ,a100` 와 같다면 특정 변수 찾기 어려워 수정하기 불편
    
<br/>

**(2) 메모리 사용 문제**

- 정수 `100`을 100개의 변수에 할당하는 경우, 파이썬이 동일한 객체를 재사용할 수도 있지만, 일반적으로 개별 값을 다루게 되면 메모리 낭비가 발생할 수 있음

```python
x1 = 9999
x2 = 9999
print(id(x1), id(x2)) >>> 5230581200 5230582608
```

✅ 큰 숫자나 리스트/딕셔너리 같은 데이터 구조는 새로운 객체가 생성됨
✅ 100개의 변수를 따로 관리하는 것은 비효율적임

→ 리스트 사용

<br/>

## **리스트를 사용하면**
- 파이썬에는 **여러 개의 값을 한꺼번에 저장할 수 있는 데이터 구조**가 있음
    → **리스트(List)** 가 가장 대표적
    

```python
numbers = [100] * 100  # 100개의 요소를 가진 리스트 생성
```

위 코드의 핵심은 `100`을 **한 번만 저장하고** 리스트 내에서 이를 **100번 참조하는 것**

→ 즉, `100`이라는 값을 **반복해서 새로 할당하는 것이 아니라, 같은 객체를 가리킴**

```python
print(id(numbers[0]), id(numbers[1]), id(numbers[99]))  # 모두 같은 메모리 주소
```

<br/>

*뭐가 좋은데?*

1. **코드가 짧고 직관적**
2. **변수를 따로 관리할 필요가 없음**
3. **메모리 낭비 없이 효율적**

*만약 값이 다른 경우라면?* → **리스트 컴프리헨션을 활용**

```python
numbers = [i for i in range(100)]
```

이렇게 하면 **0부터 99까지 자동으로 리스트에 저장**되니까, 100개의 변수를 각각 선언할 필요가 없음

<br/>

💡 **결론**

✔️ 변수를 하나씩 따로 관리하는 것은 **비효율적**

✔️ 특히, 개별 변수에 값을 할당하면 **코드가 길어지고 유지보수가 어려움**

✔️ **리스트**를 사용하면 많은 값을 **한 번에 저장**할 수 있어 **가독성과 메모리 효율성이 증가**

✔️ 동일한 값의 반복이라면, **객체 재사용을 통해 메모리 절약이 가능**

*→ 즉, **여러 개의 값을 다뤄야 한다면 리스트를 사용하자!** 🚀*

<br/>

**사용 예시**

```python
num = [2, 3, 'AA']
num[0] >> 2 # 리스트 변수 num의 첫번째 요소 접근
num[1] >> 3 # 리스트 변수 num의 두번째 요소 접근
num[2] >> 'AA' # 리스트 변수 num의 세번째 요소 접근
num[-1] >> 'AA' # 리스트 변수 num의 마지막 요소 접근
```

<br/>
<br/>

## 딕셔너리: **키(Key)로 바로 찾는 스마트 데이터 구조**

***📌 왜 딕셔너리가 필요할까?***

- 데이터를 저장할 때, 리스트(`list`)를 많이 사용함

→ 그런데 **리스트는 특정 값을 찾을 때 비효율적**

예를 들어, 학생들의 시험 점수를 저장하는 경우

```python
scores = [90, 85, 78, 92]
```

→ 리스트만 보고는 **누가 몇 점을 받았는지 알 수 없음**

```python
print(scores[0])  # 90 → 이게 누구 점수인지 모름
```

만약 **학생 이름과 점수를 매칭해야 한다면? → 딕셔너리(Dictionary)**

<br/>

---

### **📌 딕셔너리의 기본 개념**

- **Key-Value(키-값) 쌍**으로 데이터를 저장하는 구조

```python
scores = {
    "철수": 90,
    "영희": 85,
    "민수": 78
}
```

여기서:

- **Key** = `"철수"`, `"영희"`, `"민수"`
- **Value** = `90`, `85`, `78`

✅ **Key만 알면 바로 값을 찾을 수 있음!**

```python
print(scores["철수"])  # 90
```

리스트처럼 `index`로 찾는 게 아니라, **Key**로 바로 접근 가능! 🚀

<br/>

---

### **📌 딕셔너리 주요 기능**

**1️⃣ 값 추가 & 수정**

딕셔너리는 새로운 데이터를 쉽게 추가 가능

```python
scores["지수"] = 95  # 새 데이터 추가
scores["철수"] = 88  # 기존 데이터 수정
print(scores)
# {'철수': 88, '영희': 85, '민수': 78, '지수': 95}
```

**2️⃣ 값 삭제**

```python
del scores["민수"]  # '민수' 삭제
print(scores)
# {'철수': 88, '영희': 85, '지수': 95}
```

**3️⃣ 키(Key) 존재 여부 확인**

```python
print("영희" in scores)  # True
print("민수" in scores)  # False
```

<br/>

💡 **리스트 vs. 딕셔너리 차이점**

|  | 리스트(`list`) | 딕셔너리(`dict`) |
| --- | --- | --- |
| **데이터 저장** | 값만 저장 | 키-값 쌍 저장 |
| **데이터 접근** | `O(N)` (순차 탐색 필요) | `O(1)` (Key로 바로 접근 가능) |
| **사용 예시** | 번호별 학생 목록 | 학생별 성적 관리 |

<br/>
<br/>

## 조건문 (if문): **프로그램의 선택 능력 🧠**

***왜 조건문이 필요할까?***

- 사람들은 항상 **선택을 하면서 행동함**
    
    예를 들어, "비가 온다면 우산을 가져간다."
    
    → 이런 식의 논리를 프로그램에서도 사용할 수 있어야 함!
    
    = **조건문 (if문)**
    
<br/>

---

### **📌 if문의 기본 구조**

```python
if 조건식:
    실행할 코드
```

```python
**# 예제 1: 날씨에 따라 행동하기**
rain = True

if rain:
    print("우산을 가져간다.")
```

✅ `rain`이 `True`이므로 `"우산을 가져간다."` 가 출력됨.

<br/>

---

### **📌 else & elif 사용하기**

```python
# **예제 2: 성적에 따른 학점 부여**
score = 85

if score >= 90:
    print("A 학점")
elif score >= 80:
    print("B 학점")
elif score >= 70:
    print("C 학점")
else:
    print("F 학점")

```

✅ 점수가 `85`이므로 `"B 학점"`이 출력됨.

```python
**# 여러 개의 조건을 동시에 체크하려면?**
age = 20
money = 5000

if age >= 18 and money >= 3000:
    print("영화를 볼 수 있다.")
else:
    print("영화를 볼 수 없다.")
```

✅ `and` 연산자를 사용해 **두 개의 조건이 모두 참(True)일 때만 실행**되도록 함.

<br/>

---

### **📌 조건문의 핵심 개념**

| 개념 | 설명 |
| --- | --- |
| `if` | 조건이 `True`이면 실행 |
| `elif` | 다른 조건을 추가할 때 사용 |
| `else` | 모든 조건이 `False`일 때 실행 |
| 비교 연산자 | `==, !=, >, <, >=, <=` |
| 논리 연산자 | `and, or, not` |

<br/>
<br/>

## **반복문 (for문): 자동화의 시작 🔄**

***📌 왜 반복문이 필요할까?***

똑같은 코드를 여러 번 실행해야 할 때, 하나하나 작성하면 비효율적임.

```python
# **예제: 1부터 5까지 숫자 출력**
print(1)
print(2)
print(3)
print(4)
print(5)
```

이렇게 작성하는 대신, **for문을 사용하면 코드가 훨씬 간결해짐!**

```python
for i in range(1, 6):
    print(i)
```

✅ 같은 결과를 반복적으로 실행하면서도 **코드 길이를 줄일 수 있음!**

<br/>

---

### **📌 for문의 기본 구조**

```python
for 변수 in 반복할 값들:
    실행할 코드
```

- **반복할 값들**: 리스트, 튜플, 문자열 등 **`반복 가능한(iterable)` 데이터**
- **변수**: 반복될 때마다 값이 바뀌는 변수

<br/>

---

### **📌 range() 함수: 반복을 위한 숫자 생성기 🔢**

`range(start, stop, step)` 형태로 사용하며, **연속된 정수를 생성**하는 함수

**1️⃣ 기본 사용법**

```python
for i in range(5):  # 0부터 4까지 반복 (0, 1, 2, 3, 4)
    print(i)
```

**2️⃣ 특정 범위 지정**

```python
for i in range(2, 6):  # 2부터 5까지 (2, 3, 4, 5)
    print(i)
```

**3️⃣ 간격 조정**

```python
for i in range(1, 10, 2):  # 1부터 9까지 2씩 증가 (1, 3, 5, 7, 9)
    print(i)
```

<br/>

---

💡 **결론: 딕셔너리, 조건문, 반복문의 핵심**

| 개념 | 설명 | 예제 |
| --- | --- | --- |
| **딕셔너리** | Key-Value 구조로 데이터를 저장 | `dict = {"name": "철수", "age": 20}` |
| **조건문** | 조건에 따라 실행 여부 결정 | `if age >= 18: print("성인")` |
| **반복문** | 여러 번 같은 작업을 수행 | `for i in range(5): print(i)` |

<br/>

## Indexing: 데이터를 하나만 뽑아내기 🔍
**📌 "인덱싱"이란?**

인덱싱(Indexing)은 **연속된 데이터에서 특정 위치(인덱스)의 값을 가져오는 방법**

이름 그대로 **"색인을 찾아 값을 가져온다"**

<br/>

---

### **📌 리스트에서의 인덱싱**

**1️⃣ 기본적인 인덱싱**

Python에서는 **0부터 인덱스를 센다**.

```python
python
복사편집
x = [10, 20, 30, 40, 50]

print(x[0])  # 10 (첫 번째 요소)
print(x[2])  # 30 (세 번째 요소)

```

<br/>

✅ **0부터 시작하는 이유?**

컴퓨터 메모리에서 데이터를 저장할 때, **배열의 첫 번째 요소 주소를 기준으로 오프셋(offset) 값을 더해 접근하기 때문**

→ `x[0]`은 메모리상에서 **첫 번째 요소의 주소**이고, `x[1]`은 첫 번째 요소의 주소에서 **하나의 데이터 크기만큼 이동한 곳**

<br/>

---

### **2️⃣ 음수 인덱싱 (Negative Indexing)**

Python에서는 **음수 인덱스를 사용하면 뒤에서부터 접근 가능!**

```python
x = [10, 20, 30, 40, 50]

print(x[-1])  # 50 (마지막 요소)
print(x[-3])  # 30 (뒤에서 세 번째 요소)
```

<br/>

✅ **왜 음수 인덱싱이 유용할까?**

리스트의 길이를 몰라도 **마지막 요소를 쉽게 가져올 수 있음**!

```python
x = [1, 2, 3, 4, 5]
print(x[len(x) - 1])  # 5 (비효율적인 방식)
print(x[-1])  # 5 (더 간단한 방식)
```

<br/>

---

### **📌 문자열에서도 인덱싱 가능**

문자열도 **연속된 데이터(Sequence) 구조**이므로, 리스트처럼 인덱싱이 가능

```python
text = "Python"

print(text[0])   # 'P'
print(text[-1])  # 'n'
```

<br/>

✅ **문자열은 불변(Immutable) 객체**

```python
text[0] = "J"  # TypeError 발생! (문자열은 변경 불가)
```

리스트와 달리 문자열은 한 번 생성되면 **수정할 수 없음.**

→ 문자열을 변경하려면 **새로운 문자열을 만들어야 함.**

```python
text = "J" + text[1:]  # "Jython"
```

<br/>
<br/>

---

## Slicing: 여러 개를 뽑아내기 ✂️

**📌 "슬라이싱"이란?**

슬라이싱(Slicing)은 **연속된 데이터에서 원하는 범위를 잘라내는 것**

```python
# 형식
x[start:stop:step]
```

- `start` : 어디서부터 가져올지 **(포함)**
- `stop` : 어디까지 가져올지 **(미포함)**
- `step` : 몇 칸씩 건너뛸지 (**기본값=1**)

<br/>

---

### **📌 리스트에서의 슬라이싱**

**1️⃣ 기본적인 슬라이싱**

```python
x = [10, 20, 30, 40, 50]

print(x[1:4])  # [20, 30, 40] (인덱스 1부터 3까지)
```

✅ **주의할 점**: `stop` 인덱스는 **미포함** 이다!

<br/>

---

**2️⃣ 처음부터 또는 끝까지 가져오기**

```python
print(x[:3])   # [10, 20, 30] (처음부터 인덱스 2까지)
print(x[2:])   # [30, 40, 50] (인덱스 2부터 끝까지)
```

`start`나 `stop`을 생략하면 **자동으로 처음 또는 끝까지 가져옴**.

<br/>

---

**3️⃣ step을 활용한 간격 조절**

```python
x = [10, 20, 30, 40, 50, 60, 70]

print(x[::2])   # [10, 30, 50, 70] (2칸씩 건너뛰기)
print(x[1::2])  # [20, 40, 60] (인덱스 1부터 시작해 2칸씩 건너뛰기)
```

✅ `step`을 사용하면 **등차수열처럼 데이터를 건너뛰면서 가져올 수 있음**.

<br/>

---

**4️⃣ 문자열에서도 슬라이싱 가능!**

```python
text = "Python"

print(text[1:4])  # "yth" (인덱스 1부터 3까지)
print(text[:3])   # "Pyt" (처음부터 2까지)
print(text[::-1]) # "nohtyP" (문자열 뒤집기)
```

✅ `[::-1]`을 사용하면 **문자열을 뒤집을 수 있음**!

<br/>

---

### **📌 음수 인덱스를 활용한 슬라이싱**

```python
x = [10, 20, 30, 40, 50]

print(x[-4:-1])  # [20, 30, 40] (뒤에서 4번째부터 뒤에서 2번째까지)
print(x[::-1])   # [50, 40, 30, 20, 10] (리스트 뒤집기)
```

✅ 음수 인덱스와 슬라이싱을 조합하면, **유연하게 데이터를 선택할 수 있음**.

<br/>

---

### **📌 인덱싱 vs. 슬라이싱 차이점**

| 개념 | 설명 | 예제 |
| --- | --- | --- |
| **Indexing** | 특정 위치의 **하나의 값**을 가져옴 | `x[2]` → `30` |
| **Slicing** | 특정 범위의 **여러 개의 값**을 가져옴 | `x[1:4]` → `[20, 30, 40]` |

<br/>

---

## **🎯 결론**

- **Indexing** : 특정 위치의 값을 가져옴 (`x[2]`, `x[-1]`)
- **Slicing** : 특정 범위의 여러 값을 가져옴 (`x[1:4]`, `x[::-1]`)
- **문자열과 리스트에서 모두 사용 가능**
- **음수 인덱스를 활용하면 끝에서부터 접근 가능**

<br/>
<br/>

---

## Tuple

- **리스트와 유사하지만 변경할 수 없는(Immutable) 자료형**
    
    **→ 한 번 정의하면 내부 값을 수정하거나 삭제할 수 없음**
    

그렇다면 왜 이런 자료형이 필요할까? 🤔

<br/>

---

### **✅ 튜플의 기본적인 특징**

| 특징 | 설명 |
| --- | --- |
| **변경 불가능(Immutable)** | 한 번 생성된 튜플은 요소를 수정, 삭제할 수 없음 |
| **괄호 사용** | `()` 소괄호로 정의 |
| **리스트와 유사** | 순서(인덱스)가 있고, 여러 개의 요소를 저장 가능 |
| **더 빠름** | 리스트보다 속도가 빠름 (메모리 사용 최적화) |
| **데이터 안전성** | 값이 변경되지 않으므로, 중요한 데이터 보호에 유용 |

---

### **📌 Tuple(튜플) 생성 방법**

튜플을 생성하는 방법은 매우 간단함

```python
# 기본적인 튜플 생성
t = (1, 2, 3)
print(t)  # (1, 2, 3)
```

<br/>

✅ 튜플은 `()` 소괄호를 사용해 정의함

```python
# 여러 타입의 데이터 저장 가능
t2 = (10, "hello", 3.14)
print(t2)  # (10, 'hello', 3.14)
```

튜플도 리스트처럼 다양한 타입을 함께 저장할 수 있다는 것.

<br/>

---

### **📌 튜플은 변경할 수 없다! (Immutable)**

튜플은 한 번 정의되면 **요소를 수정할 수 없음**

```python
t = (1, 2, 3)
t[0] = 100  # TypeError 발생! (튜플은 수정 불가)
```

<br/>

✅ **리스트는 변경 가능하지만, 튜플은 불가능!**

튜플과 리스트의 가장 큰 차이점임

```python
# 리스트는 변경 가능
lst = [1, 2, 3]
lst[0] = 100
print(lst)  # [100, 2, 3]
```

<br/>

---

### **📌 튜플의 요소 접근 (Indexing & Slicing)**

튜플도 리스트처럼 **인덱싱과 슬라이싱**이 가능!

**✅ 인덱싱(Indexing)**

```python
t = (10, 20, 30, 40, 50)

print(t[0])   # 10 (첫 번째 요소)
print(t[-1])  # 50 (마지막 요소)
```

✅ 리스트와 동일하게 **0부터 시작하는 인덱스**를 사용해 접근할 수 있음

<br/>

---

**✅ 슬라이싱(Slicing)**

```python
print(t[1:4])  # (20, 30, 40) (인덱스 1부터 3까지)
print(t[:3])   # (10, 20, 30) (처음부터 2까지)
print(t[::2])  # (10, 30, 50) (2칸씩 건너뛰기)
```

✅ 슬라이싱도 리스트처럼 사용 가능하지만, **새로운 튜플을 생성하는 것임**

→ 튜플 자체를 변경하는 게 아니라 **일부 요소를 포함한 새로운 튜플을 반환**하는 것!

<br/>

---

### **📌 튜플과 리스트의 차이점 (Tuple vs. List)**

| 특징 | 튜플(Tuple) | 리스트(List) |
| --- | --- | --- |
| **기본 문법** | `(1, 2, 3)` | `[1, 2, 3]` |
| **수정 가능 여부** | ❌ 변경 불가능 | ✅ 변경 가능 |
| **삽입, 삭제 가능 여부** | ❌ 추가/삭제 불가 | ✅ 추가/삭제 가능 |
| **속도** | ✅ 더 빠름 | ❌ 상대적으로 느림 |
| **사용 목적** | 변경되지 않는 데이터 저장 | 가변적인 데이터 저장 |

✅ **튜플은 불변(Immutable) 속성 덕분에 리스트보다 속도가 빠르고 안전성이 높음!**

→  **"변경할 필요 없는 데이터"를 저장할 때 튜플을 사용하면 더 효율적**

<br/>

---

**3️⃣ 딕셔너리의 키(key)로 사용**

튜플은 **변경할 수 없기 때문에 딕셔너리의 키로 사용 가능**

리스트는 변경 가능하므로 **딕셔너리 키로 사용할 수 없음**

```python
location = {(37.5665, 126.9780): "서울", (35.1796, 129.0756): "부산"}

print(location[(37.5665, 126.9780)])  # 서울
```

✅ **튜플은 해시 가능(Hashable)하므로 딕셔너리 키로 사용 가능!**

<br/>

---

### **📌 Tuple Unpacking(튜플 언패킹)**

튜플의 요소를 한 번에 여러 변수에 저장할 수 있음

```python
t = (10, 20, 30)

a, b, c = t  # 튜플 언패킹
print(a, b, c)  # 10 20 30
```

✅ 튜플 언패킹을 활용하면 코드를 더 깔끔하게 작성 가능!

<br/>

---

### **📌 튜플을 리스트로 변환 (반대로도 가능)**

튜플과 리스트는 `list()`와 `tuple()`을 이용해 서로 변환 가능

```python
t = (1, 2, 3)
lst = list(t)  # 튜플 → 리스트
lst.append(4)  # 리스트이므로 수정 가능
print(lst)  # [1, 2, 3, 4]

new_tuple = tuple(lst)  # 리스트 → 튜플
print(new_tuple)  # (1, 2, 3, 4)
```

✅ 튜플은 변경할 수 없지만, **리스트로 변환하면 변경 가능**!

변경 후 다시 튜플로 변환하는 방법도 있음

<br/>

---

### **📌 튜플 메서드**

튜플은 불변(Immutable)이므로 사용할 수 있는 메서드가 몇 개 없음

| 메서드 | 설명 |
| --- | --- |
| `count(value)` | 해당 값이 몇 번 등장하는지 반환 |
| `index(value)` | 해당 값의 첫 번째 인덱스를 반환 |

```python
t = (1, 2, 3, 2, 2, 4)

print(t.count(2))  # 3 (2가 등장한 횟수)
print(t.index(3))  # 2 (3이 처음 나타난 위치)
```

<br/>

---

### ✅ 튜플(Tuple)의 핵심 정리

✔ **변경 불가능 (Immutable) → 리스트와 가장 큰 차이점**

✔ **빠르고 메모리 효율이 좋음**

✔ **리스트와 거의 동일하게 인덱싱, 슬라이싱 가능**

✔ **함수 반환 값, 변경되지 않는 데이터 저장, 딕셔너리 키로 사용 가능**

✔ **튜플 언패킹을 활용하면 코드가 깔끔해짐**
